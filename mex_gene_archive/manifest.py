import csv
import logging
import hashlib

#######
# Functions for making manifest
#
logger = logging.getLogger(__name__)
IO_BUFFER = 2 ** 10


class ConfigError(ValueError):
    """Indicate the config dictionary isn't correct"""
    pass


def compute_md5sums(filenames):
    results = []
    for f in filenames:
        with open(f, "rb") as instream:
            md5 = compute_stream_md5sum(instream)
        results.append((f, md5.hexdigest()))
    return results


def compute_stream_md5sum(instream):
    """Compute the md5sum of a file-like object
    """
    md5 = hashlib.md5()
    readable = instream.readable()
    while readable:
        read_block = instream.read(IO_BUFFER)
        if len(read_block) == 0:
            readable = False
        else:
            md5.update(read_block)
    return md5


def create_metadata(config, md5s):
    metadata = {
        "type": "MexGeneArchive_v1",
        "output_type": config['output_type'],
        "software_version": config["software_version"],
        "arguments": config["arguments"],
    }
    for key in ["experiment_accession", "description", "library_accession"]:
        if key in config:
            metadata[key] = config[key]

    for filename, md5 in md5s:
        metadata[filename] = "md5sum:{}".format(md5)

    return metadata

def validate_config_metadata(config):
    not_user = ["type", "output_type", "software_version", "arguments"]
    user = ["experiment_accession", "description", "library_accession"]
    has_errors = False

    for key in not_user:
        if key in config:
            logger.error("{} will be generated by the pipeline")
            has_errors = True

    for key in user:
        if key not in config:
            logger.error("{} needs to be provided in the config file")
            has_errors = True

    if has_errors:
        raise ConfigError("Invalid attributes in config file")


def write_manifest(outstream, config):
    writer = csv.writer(outstream, delimiter="\t")
    writer.writerow(["name", "value"])
    for key in config:
        writer.writerow([key, config[key]])
    return outstream


def read_manifest(instream):
    reader = csv.reader(instream, delimiter="\t")
    header = None
    metadata = {}
    for row in reader:
        if header is None:
            header = row
        else:
            metadata[row[0]] = row[1]
    return metadata
